import { Dialog } from './index';

new Dialog(
    /**
     * Первым аргументом Dialog принимает класс-состояние сессии.
     * Экземпляр этого класса будет создан для новой сессии. Для всех
     * следующих запросов он будет восстанавливаться из хранилица Диалогов
     * и сохраняться в него.
     *
     *  Не забудьте включить хранилище данных в настройках навыка.
     *
     *  Можно передать пустой класс `class Model {}`.
     */
    class Model {
        private count = 0;

        getCount() {
            return this.count;
        }

        increment() {
            this.count++;
        }

        decrement() {
            this.count--;
        }
    },
    {
        /**
         * Диалог состоит из сцен и переходов. Каждая сцена определяет,
         * что будет выведено пользователю и как будет обработан ввод.
         *  - Сцена всегда ожидает ответа от пользователя.
         *  - Переход не ожидает ответа, но перемещает диалог к следующему переходу,
         *    пока не будет достигнута сцена. Когда диалог достигнет сцены,
         *    пользователю будет выведет ответ всех пройденных переходов
         *    и текущей сцены.
         *
         * Сцены и переходы отличаются наличием обработчиков:
         *  - onInput у сцены
         *  - onTransition у перехода
         */
        scenes: {
            /**
             * Диалог всегда начинается со сцены (или перехода) Start. Это соглашение.
             */
            Start: {
                /**
                 * Ответ пользователю описывается в функции reply,
                 * которая первым параметром принимает ReplyBuilder.
                 */
                reply(reply) {
                    reply.withText('Начнём считать.');
                },
                /**
                 * Сцены и переходы возвращают название следующей сцены или перехода.
                 */
                onTransition() {
                    return 'ChangeCount';
                },
            },
            ChangeCount: {
                reply(reply) {
                    /**
                     * В ReplyBuilder есть ещё несколько методов.
                     */
                    reply.withText('Скажите «Плюс» или «Минус».');
                    reply.withButton('Плюс');
                    reply.withButton('Минус');
                },
                /**
                 * onInput первым параметром принимает объект Input,
                 * который содержит данные ввода пользователя в удобной форме
                 * (также есть request в неизменном виде).
                 *
                 * Вторым и третьим параметрами onInput принимает состояние
                 * и метод для его изменения.
                 */
                onInput({ command }, state) {
                    if (command === 'плюс') {
                        state.increment();

                        return 'SayCount';
                    }

                    if (command === 'минус') {
                        state.decrement();

                        return 'SayCount';
                    }
                },
                /**
                 * В сцене можно указать обработчик unrecognized.
                 * Он отработает, если onInput вернёт undefined.
                 * При этом диалог останется в на той же сцене.
                 *
                 * Если обработчик unrecognized не указан, будет выполнен
                 * обработчик help текущей сцены или reply последней сцены.
                 */
                unrecognized(reply) {
                    reply.withText('Повторите, пожалуйста. Вы сказали «Плюс» или «Минус»?');
                },
                /**
                 * В сцене можно указать обработчик help.
                 * Он отработает, если будет получен интент YANDEX.HELP или команда «Помощь».
                 * При этом диалог останется в на той же сцене.
                 *
                 * Если обработчик help не указан, будет выполнен
                 * обработчик unrecognized текущей сцены или reply последней сцены.
                 *
                 * Каждая сцена содержит свой собственный обработчик help,
                 * т.к. подсказки в диалоге должны быть привязаны к контексту.
                 * Для рассказа о навыке вцелом служит обработчик whatCanYouDo (см. ниже).
                 */
                help(reply) {
                    reply.withText(
                        'Сейчас вы можете изменить счётчик.',
                        'Для этого скажите «Плюс» или «Минус».'
                    );
                },
            },
            SayCount: {
                /**
                 * Вторым параметром reply принимает состояние.
                 * Изменение состояния в reply не предусмотрено.
                 */
                reply(reply, state) {
                    reply.withText(`Теперь у вас ${state.getCount()}.`);
                },
                /**
                 * onTransition, как и onInput, принимает состояние
                 * и метод для его изменения. Менять состояние можно
                 * только в onInput и onTransition.
                 */
                onTransition(state) {
                    if (state.getCount() < 3 && state.getCount() > -3) {
                        return 'Quit';
                    }

                    return 'ChangeCount';
                },
            },
            Quit: {
                reply(reply, state) {
                    reply.withText(`Теперь у вас ${state.getCount()}. Этого достаточно.`);
                },
                onInput() {
                    return 'Start';
                },
            },
        },
        /**
         * Отрабатывает на интент YANDEX.WHAT_CAN_YOU_DO или комаду
         * «Что ты умеешь». К этому ответу добавляется reply текущей
         * сцены чтобы пользователь не потерял контекст.
         */
        whatCanYouDo(reply) {
            reply.withText(`Этот навык помогает считать.`);
        },
        /**
         * Если обработчик timeout будет передан, то будет установлен таймен
         * на 2700мс. Если таймер сработает раньше, чем диалог вернёт обычный ответ,
         * то в ответ будет возвращён результат работы timeout.
         */
        timeout(reply) {
            reply.withText(`Ой! Простите, я отвлеклась. Что вы сказали?`);
        }
    }
);
